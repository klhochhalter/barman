#!/bin/bash

RESET_IFS=$IFS
BARMAN='/usr/bin/barman'
LOG_FILE='/var/log/barman/barman_run_backups.log'
VERBOSE=0
FOR_REAL=1
CHECK_STATUS=0

# The maximum number of concurrent backups to
# run at any given time.
#
# Set to zero for unlimited concurrency.
# NOTE: This is NOT recommended.
#
# This can be overriden with the -c switch.
MAX_CONCURRENT_BACKUPS=1

# This is the minimum age in seconds for a backup.
# If the age of the most recent backup for a server is
# more than this many seconds, a backup will be forced.
#
# The default is 604800 seconds, or one week.
# This can be overriden with the -a switch.
#MIN_BACKUP_AGE=604800
MIN_BACKUP_AGE=7200

BACKUP_LIST=()
LOCK_FILES=()

function _log {
# ALL messages of level ERROR go to stderr.
LOG_LEVEL=$1
LOG_MESSAGE=$2
IFS="$(printf '\n\t')"
DATE=`date "+%FT%T"`

for LOG_LINE in $LOG_MESSAGE; do
    echo `printf "%s %s [%s] %s: %s" "$DATE" "$(basename $0)" "$$" "$LOG_LEVEL" "$LOG_LINE"` >> $LOG_FILE
done

IFS=""
[ $VERBOSE -eq 1 ] && echo $2
[ $VERBOSE -eq 0 ] && [ $1 == 'ERROR' ] && echo $2 >&2
IFS=$RESET_IFS
}

while getopts htsva:c: opt; do
    case $opt in
        v) # be verbose
            VERBOSE=1
        ;;
        a) # min backup age in seconds
            MIN_BACKUP_AGE=$OPTARG
        ;;
        c) # number of concurrent backups
            MAX_CONCURRENT_BACKUPS=$OPTARG
        ;;
        t) # run in test mode
            FOR_REAL=0
            VERBOSE=1
            _log INFO "Running in test mode. Not taking any action."
        ;;
        s) # check status
            FOR_REAL=0
            VERBOSE=1
            CHECK_STATUS=1
        ;;
        h|H)
            echo "`basename $0` [-vamts] [-h]"
            exit 0
    esac
done

read -a SERVERS <<< `$BARMAN list-server`

# Check for lock_files/running backups.
for SERVER in ${SERVERS[*]}; do
    LOCK_FILE=`$BARMAN show-server $SERVER | grep 'lock_file' | awk '{print $2}'`
    if [ -e $LOCK_FILE ]; then
        LOCK_FILES=( "${LOCK_FILES[@]}" "$LOCK_FILE" )
    fi
done

for SERVER in ${SERVERS[*]}; do
    LAST_BACKUP=`$BARMAN list-backup $SERVER | head -n 1`

    # Skip the server if the most recent backup is in progress or has failed.
    echo $LAST_BACKUP | grep -E -q 'STARTED|FAILED' && continue

    # barman list-backup <server> prints the output in this format:
    # <server> <backup_id> - <backup_end_time> - <backup_size> - <wal_size> [ - <status> ]
    # pg-001 20130423T163355 - Tue Apr 23 16:37:41 2013 - Size: 45.0 MiB - WAL Size: 16.0 MiB
    # What we're looking for is the backup_id, which is YYYYMMDDTHHMMSS
    # Split up the backup_id and turn it into something we can pass to date
    # to extract the epoch.
    #
    # Note: We don't use the backup_end_time, since the formatting could change in future
    # barman versions. The backup_id should be consistent, so use it.

    read -a LAST_BACKUP_TIMESTAMP <<< \
        `echo $LAST_BACKUP \
        | awk '{print $2}' \
        | sed 's/^ *//g' \
        | tr "T" " "`

    YMD=${LAST_BACKUP_TIMESTAMP[0]}
    HMS=${LAST_BACKUP_TIMESTAMP[1]}
    LAST_BACKUP_EPOCH=`date -d "$YMD ${HMS:0:2}:${HMS:2:2}:${HMS:4:2}" +%s`
    MIN_BACKUP_EPOCH=`date -d "$MIN_BACKUP_AGE seconds ago" +%s`

    if [ $LAST_BACKUP_EPOCH -lt $MIN_BACKUP_EPOCH ]; then
        BACKUP_LIST=( "${BACKUP_LIST[@]}" "$LAST_BACKUP" )
    fi
done

if [ $CHECK_STATUS -eq 1 ]; then
    IFS=""
    echo "List of servers requiring backup:"
    for BACKUP in ${BACKUP_LIST[@]}; do
        echo "$BACKUP"
    done
    echo "List of lock files (backup may be underway):"
    for LOCK_FILE in ${LOCK_FILES[@]}; do
        echo "$LOCK_FILE"
    done
    IFS=$RESET_IFS
    exit 0
fi

if [ $MAX_CONCURRENT_BACKUPS -ne 0 ] && [ ${#LOCK_FILES[@]} -ge $MAX_CONCURRENT_BACKUPS ]; then
IFS="" MESSAGE=`cat << EOM
${#LOCK_FILES[@]} backup(s) already running.
Max allowed concurrent backups is $MAX_CONCURRENT_BACKUPS
Aborting run.
EOM`
_log WARN $MESSAGE
exit 0
fi

if [ ${#BACKUP_LIST[@]} -gt 0 ]; then
    LEN=`expr ${#BACKUP_LIST[@]} - 1`
    for i in `seq 0 $LEN`; do
        SERVER=`echo ${BACKUP_LIST[$i]} | awk '{print $1}'`
        # skip if there is a lock file.
        echo ${LOCK_FILES[*]} | grep -q  $SERVER && continue
        IFS="" MESSAGE=`cat << EOM
starting backup
server: $SERVER
last backup was: ${BACKUP_LIST[$i]}
EOM`
        _log INFO $MESSAGE

        [ $FOR_REAL -eq 0 ] && exit 0

        RETVAL=`$BARMAN backup $SERVER 2>&1`
        if [ $? -ne 0 ]; then
            _log ERROR "backup failed for server $SERVER:"
            _log ERROR $RETVAL
            exit 1
        else
            _log INFO "backup finished for server $SERVER"
            exit 0
        fi
        exit 0
    done
fi

_log INFO "No backups need to be done at this time."
exit 0

